//@author: vux
//@help: template for geometry fx
//@tags: geometry
//@credits:

SamplerState linearSampler: IMMUTABLE
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};

cbuffer cbPerDraw : register(b0)
{
	float4x4 tVP : LAYERVIEWPROJECTION;
};

struct vs2gs
{
	float3 PosO: POSITION;
	float3 Normal: NORMAL;
	float2 UV: TEXCOORD0;
};

struct GSout
{
	float4 Pos: POSITION;
};

vs2gs VS(
	float3 PosO: POSITION,
	float3 Normal: NORMAL,
	float2 UV: TEXCOORD0,
	uint InstanceID: SV_VertexID)
{
	vs2gs Out;
	
	Out.PosO = PosO;
	Out.Normal = Normal;
	Out.UV = UV;
	
    return Out;
}

[maxvertexcount(24)]
void Cone(point vs2gs input[1], inout LineStream<GSout> gsout)
{	
	GSout o;
	float3 cpos[] = {float3(0, 0, -1),
					 float3(1, 1, 1),
					 float3(-1, 1, 1),
					 float3(1, -1, 1),
					 float3(-1, -1, 1)
					};
	for(int i = 0; i < 3; i++){
		o.Pos = mul(cpos[i], tVP);
		gsout.Append(o);
	}
	o.Pos = cpos[0];
	
	for(i = 3; i < 5; i++){
		o.Pos = mul(cpos[i], tVP);
		gsout.Append(o);
	}
	gsout.RestartStrip();
	
	o.Pos = mul(cpos[1], tVP);
	gsout.Append(o);
	o.Pos = mul(cpos[3], tVP);
	gsout.Append(o);
	gsout.RestartStrip();
	
	o.Pos = mul(cpos[2], tVP);
	gsout.Append(o);
	o.Pos = mul(cpos[4], tVP);
	gsout.Append(o);	
	gsout.RestartStrip();
}

GeometryShader StreamOutGS = ConstructGSWithSO( CompileShader( gs_5_0, Cone() ), "POSITION.xyz;NORMAL.xyz;TEXCOORD.xy", NULL,NULL,NULL,-1 );
//if the above does not work, try this line instead
//GeometryShader StreamOutGS = ConstructGSWithSO( CompileShader( vs_4_0, VS() ), "POSITION.xyz;NORMAL.xyz;TEXCOORD.xy" );

technique10 PassMesh
{
    pass PP2
    {
        SetVertexShader( CompileShader( vs_4_0, VS() ) );
        SetGeometryShader( StreamOutGS );
    }  
}